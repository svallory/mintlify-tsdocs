import * as path from 'path';

import { CommandLineAction, type CommandLineRemainder, type CommandLineFlagParameter } from '@rushstack/ts-command-line';
import { FileSystem } from '@rushstack/node-core-library';
import * as clack from '@clack/prompts';
import { S_BAR, S_BAR_END } from './utils/constants';
import { ESLint } from 'eslint';
import { Extractor, ExtractorConfig, type ExtractorResult } from '@microsoft/api-extractor';
import { loadConfig, generateApiExtractorConfig } from '../config';
import { DocumentationError, ErrorCode } from '../errors/DocumentationError';
import { formatTitle, multiLineOutro, showCliHeader, showSectionHeader } from './CliHelpers';
import { IssueDisplayUtils, type IssueMessage, type IssueGroup, type IssueSeverity } from './IssueDisplayUtils';
import chalk from 'chalk';
import type { DocumenterCli } from './ApiDocumenterCommandLine';
import { ApiExtractorService } from './services/ApiExtractorService';


/**
 * CLI action for linting documentation quality.
 *
 * @public
 */
export class LintAction extends CommandLineAction {
  /**
   * Tracks seen issues to avoid duplicates between API Extractor and ESLint
   * Key format: messageId:filePath:line
   */
  private _seenIssues = new Set<string>();

  /**
   * Tracks if we've shown the API Extractor verbose output header
   */
  private _shownApiExtractorHeader = true;

  /**
   * Optional folder path to lint (instead of entire project)
   */
  private readonly _folderRemainder: CommandLineRemainder;

  /**
   * Reference to parent parser for accessing verbose flag
   */
  private readonly _parser: DocumenterCli;

  /**
   * Command-line flag to show verbose output
   */
  private readonly _verboseParameter: CommandLineFlagParameter;

  public constructor(parser: DocumenterCli) {
    super({
      actionName: 'lint',
      summary: 'Check documentation quality and find issues',
      documentation:
        'Analyzes API documentation and reports:\n' +
        '  - Undocumented public APIs\n' +
        '  - Missing parameter descriptions\n' +
        '  - Missing return type descriptions\n' +
        '  - Missing examples for complex APIs\n\n' +
        'Usage:\n' +
        '  mint-tsdocs lint [PATH] [OPTIONS]\n\n' +
        'Examples:\n' +
        '  mint-tsdocs lint                    # Lint entire project\n' +
        '  mint-tsdocs lint ./src/core         # Lint specific folder\n' +
        '  mint-tsdocs lint ./src/index.ts     # Lint specific file\n' +
        '  mint-tsdocs lint --verbose          # Show verbose output\n' +
        '  mint-tsdocs lint --help             # Show help'
    });

    this._parser = parser;

    this._verboseParameter = this.defineFlagParameter({
      parameterLongName: '--verbose',
      parameterShortName: '-v',
      description: 'Show detailed output including API Extractor and ESLint progress'
    });

    this._folderRemainder = this.defineCommandLineRemainder({
      description: 'Optional file or folder path to lint (default: entire project)'
    });
  }

  protected override async onExecuteAsync(): Promise<void> {
    // Reset state for each run
    this._shownApiExtractorHeader = false;

    showCliHeader();
    clack.log.message(chalk.bold('Documentation Linting'));

    try {
      const config = loadConfig(process.cwd());

      // Resolve paths
      const projectDir = process.cwd();
      const tsdocsDir = path.join(projectDir, 'docs', '.tsdocs');

      // Get optional path filter from arguments (folder or file)
      const remainingArgs = this._folderRemainder.values;
      let pathFilter: string | undefined;
      let isFileFilter = false;
      if (remainingArgs && remainingArgs.length > 0) {
        const rawPath = remainingArgs[0];
        pathFilter = path.resolve(projectDir, rawPath);

        // Validate path exists
        if (!FileSystem.exists(pathFilter)) {
          clack.log.error(`Path not found: ${rawPath}`);
          clack.outro('Please provide a valid file or folder path');
          return;
        }

        // Check if it's a file or directory
        const stats = FileSystem.getLinkStatistics(pathFilter);
        isFileFilter = stats.isFile();

        if (isFileFilter) {
          clack.log.info(`Linting file: ${chalk.cyan(rawPath)}`);
        } else {
          clack.log.info(`Linting folder: ${chalk.cyan(rawPath)}`);
        }
      }

      // Use existing api-extractor.json from .tsdocs (generated by generate command)
      const apiExtractorConfigPath = path.join(tsdocsDir, 'api-extractor.json');

      if (!FileSystem.exists(apiExtractorConfigPath)) {
        clack.log.error('No api-extractor.json found.');
        clack.outro(
          'Run ' + chalk.cyan('mint-tsdocs generate') + ' first to generate the API Extractor configuration'
        );
        return;
      }

      // Collections for all issues
      const issueGroups = new Map<string, IssueMessage[]>();
      const ungroupedIssues: IssueMessage[] = [];

      // Step 1: Run api-extractor to collect TSDoc/syntax warnings
      await this._runApiExtractor(apiExtractorConfigPath, issueGroups, ungroupedIssues, pathFilter, isFileFilter);

      if (this._verboseParameter.value) {
        clack.log.success(`API Extractor analysis complete`);
      }

      // Step 2: Run ESLint with tsdoc plugin (if enabled)
      if (config.lint?.eslint?.enabled !== false) {
        let eslintSpinner: ReturnType<typeof clack.spinner> | null = null;
        if (this._verboseParameter.value) {
          eslintSpinner = clack.spinner();
          eslintSpinner.start('Running ESLint with TSDoc plugin...');
        }
        await this._runESLint(config, projectDir, issueGroups, ungroupedIssues, eslintSpinner, pathFilter, isFileFilter);
        if (eslintSpinner) {
          eslintSpinner.stop('ESLint analysis complete');
        }
      }

      if (this._verboseParameter.value) {
        clack.outro('Done!');
      }

      // Display all collected issues
      showSectionHeader('Documentation Issues');
      this._displayIssues(issueGroups, ungroupedIssues, config);
    } catch (error) {
      if (error instanceof DocumentationError && error.code === ErrorCode.CONFIG_NOT_FOUND) {
        clack.log.error('No mint-tsdocs configuration found.');
        clack.outro('Run ' + chalk.cyan('mint-tsdocs init') + ' to create a configuration file');
      } else {
        throw error;
      }
    }
  }

  /**
   * Run API Extractor to collect TSDoc syntax warnings
   */
  private async _runApiExtractor(
    configPath: string,
    issueGroups: Map<string, IssueMessage[]>,
    ungroupedIssues: IssueMessage[],
    pathFilter?: string,
    isFileFilter?: boolean
  ): Promise<void> {
    try {
      const result = await ApiExtractorService.run({
        configPath,
        suppressConsole: true,
        showVerboseMessages: false,
        messageHandler: (message) => {
          // Skip suppressed messages
          if (message.logLevel === 'none') {
            return;
          }

          // Write verbose/info messages immediately to stdout so they appear in correct order
          // These are messages like "Analysis will use TypeScript version..." that should appear early
          // Only show in verbose mode
          if (message.logLevel === 'verbose' || message.logLevel === 'info') {
            if (this._verboseParameter.value) {
              // Show header before first verbose message
              if (!this._shownApiExtractorHeader) {
                clack.log.step(chalk.dim('Running API Extractor'));
                console.log(chalk.gray(S_BAR));
                this._shownApiExtractorHeader = true;
              }

              console.log(chalk.gray(S_BAR) + '  ' + message.text);
            }
            return;
          }

          // Create deduplication key using messageId + file + line
          const dedupeKey = `${message.messageId}:${message.sourceFilePath}:${message.sourceFileLine}`;

          // Skip if already seen
          if (this._seenIssues.has(dedupeKey)) {
            return;
          }
          this._seenIssues.add(dedupeKey);

          // Apply path filter if specified
          if (pathFilter && message.sourceFilePath) {
            const normalizedSourcePath = path.resolve(message.sourceFilePath);
            if (isFileFilter) {
              // For file filter, only include issues from the exact file
              if (normalizedSourcePath !== pathFilter) {
                return; // Skip issues from other files
              }
            } else {
              // For folder filter, include issues from files within the folder
              if (!normalizedSourcePath.startsWith(pathFilter)) {
                return; // Skip issues outside the filtered folder
              }
            }
          }

          // Create issue message
          const issue: IssueMessage = {
            text: message.text,
            severity: IssueDisplayUtils.logLevelToSeverity(message.logLevel),
            line: message.sourceFileLine,
            column: message.sourceFileColumn
          };

          // Group by file or collect without location
          if (message.sourceFilePath) {
            const fileKey = message.sourceFilePath;
            if (!issueGroups.has(fileKey)) {
              issueGroups.set(fileKey, []);
            }
            issueGroups.get(fileKey)!.push(issue);
          } else {
            ungroupedIssues.push(issue);
          }
        }
      });

      if (!result.succeeded) {
        clack.log.warn(
          `API Extractor completed with ${result.errorCount} errors and ${result.warningCount} warnings`
        );
      }
    } catch (error) {
      clack.log.warn('API Extractor analysis failed: ' + (error instanceof Error ? error.message : String(error)));
    }
  }

  /**
   * Run ESLint with tsdoc plugin on source files
   */
  private async _runESLint(
    config: any,
    projectDir: string,
    issueGroups: Map<string, IssueMessage[]>,
    ungroupedIssues: IssueMessage[],
    spinner: ReturnType<typeof clack.spinner> | null,
    pathFilter?: string,
    isFileFilter?: boolean
  ): Promise<void> {
    // Check if ESLint is enabled in config
    if (!config.lint?.eslint?.enabled) {
      return;
    }

    // Suppress stderr to hide Node.js warnings (like MODULE_TYPELESS_PACKAGE_JSON)
    const originalStderrWrite = process.stderr.write;
    const noopWrite = (chunk: any, encoding?: any, callback?: any): boolean => {
      const cb = typeof encoding === 'function' ? encoding : callback;
      if (cb) setImmediate(cb);
      return true;
    };
    (process.stderr as any).write = noopWrite;

    try {
      // Determine which paths to lint
      let pathsToLint: string[];
      if (pathFilter) {
        // If path filter is specified, use it directly (file or folder)
        pathsToLint = [pathFilter];
      } else {
        // Otherwise, use directories from config
        const configDirs = config.lint.eslint.directories || ['src'];
        pathsToLint = configDirs
          .map((dir: string) => path.join(projectDir, dir))
          .filter((dir: string) => FileSystem.exists(dir));
      }

      if (pathsToLint.length === 0) {
        // Restore stderr before returning
        (process.stderr as any).write = originalStderrWrite;
        if (spinner) {
          spinner.stop('No source paths found for linting');
        }
        return;
      }

      // Import plugins
      const tsdocPlugin = await import('eslint-plugin-tsdoc');
      // @ts-expect-error - Dynamic import type resolution
      const typescriptParser = await import('@typescript-eslint/parser');

      // Determine tsconfig path for parser
      const tsConfigPath = path.join(projectDir, 'tsconfig.json');
      const hasTsConfig = FileSystem.exists(tsConfigPath);

      // Create ESLint instance
      const eslintOptions: any = {
        cwd: projectDir,
        // DO NOT set overrideConfigFile: true - allow auto-discovery

        // Add base config if user doesn't have ESLint config
        baseConfig: [{
          plugins: {
            tsdoc: tsdocPlugin.default
          },
          languageOptions: {
            parser: typescriptParser.default,
            parserOptions: hasTsConfig ? {
              project: tsConfigPath,
              ecmaVersion: 2018,
              sourceType: 'module'
            } : {
              ecmaVersion: 2018,
              sourceType: 'module'
            }
          }
        }],

        // Override config to ensure tsdoc rules are checked
        overrideConfig: [{
          plugins: {
            tsdoc: tsdocPlugin.default
          },
          rules: {
            // User's eslint.config.js can override this severity
            'tsdoc/syntax': 'warn'
          }
        }]
      };

      // Use custom config path if specified
      if (config.lint.eslint.configPath) {
        eslintOptions.overrideConfigFile = config.lint.eslint.configPath;
      }

      const eslint = new ESLint(eslintOptions);

      // Lint paths (ESLint discovers files internally for directories)
      const results = await eslint.lintFiles(pathsToLint);

      // Convert ESLint results to grouped format
      for (const result of results) {
        if (result.messages.length === 0) continue;

        const filePath = result.filePath;

        for (const message of result.messages) {
          // Only process tsdoc-related messages
          if (!message.ruleId || !message.ruleId.startsWith('tsdoc/')) {
            continue;
          }

          // Create deduplication key
          const dedupeKey = `${message.ruleId}:${filePath}:${message.line}`;

          // Skip if already seen from API Extractor
          if (this._seenIssues.has(dedupeKey)) {
            continue;
          }
          this._seenIssues.add(dedupeKey);

          const severity: IssueSeverity =
            message.severity === 2
              ? 'error'
              : message.severity === 1
                ? 'warning'
                : 'info';

          const issue: IssueMessage = {
            text: `${message.message}`,
            severity,
            line: message.line,
            column: message.column
          };

          if (!issueGroups.has(filePath)) {
            issueGroups.set(filePath, []);
          }
          issueGroups.get(filePath)!.push(issue);
        }
      }
    } catch (error) {
      // Restore stderr
      (process.stderr as any).write = originalStderrWrite;

      // Stop spinner and log warning
      if (spinner) {
        spinner.stop('ESLint analysis skipped');
      }
      clack.log.warn(
        'Reason: ' + (error instanceof Error ? error.message : String(error))
      );
    } finally {
      // Always restore stderr
      (process.stderr as any).write = originalStderrWrite;
    }
  }

  /**
   * Display lint issues using grouped format
   */
  private _displayIssues(
    issueGroups: Map<string, IssueMessage[]>,
    ungroupedIssues: IssueMessage[],
    config: any
  ): void {
    // Count total issues and by severity
    let totalIssues = ungroupedIssues.length;
    let errorCount = 0;
    let warningCount = 0;
    let infoCount = 0;

    for (const issues of issueGroups.values()) {
      totalIssues += issues.length;
      for (const issue of issues) {
        if (issue.severity === 'error') errorCount++;
        else if (issue.severity === 'warning') warningCount++;
        else if (issue.severity === 'info') infoCount++;
      }
    }

    for (const issue of ungroupedIssues) {
      if (issue.severity === 'error') errorCount++;
      else if (issue.severity === 'warning') warningCount++;
      else if (issue.severity === 'info') infoCount++;
    }

    if (totalIssues === 0) {
      console.log('\n' + chalk.green('âœ“ No documentation issues found!'));
      clack.outro('Your documentation looks great!');
      return;
    }

    // Convert Map to IssueGroup array
    const groups: IssueGroup[] = Array.from(issueGroups.entries()).map(([filePath, issues]) => ({
      filePath,
      issues
    }));

    // Display grouped issues using IssueDisplayUtils
    IssueDisplayUtils.displayGroupedIssues(groups, ungroupedIssues);

    // Display summary with section header
    clack.intro(formatTitle('Summary', 2));

    clack.log.info('Info:            ' + chalk.cyan(infoCount.toString()));
    clack.log.error('Errors:          ' + chalk.red(errorCount.toString()));
    clack.log.warn('Warnings:        ' + chalk.yellow(warningCount.toString()));

    // Exit with error code if configured and there are errors
    const shouldFail = config.lint?.failOnError ?? true;
    if (errorCount > 0 && shouldFail) {
      clack.outro(chalk.red(`Found ${errorCount} error(s). Fix these issues first.`));
      process.exitCode = 1;
    } else if (errorCount > 0) {
      clack.outro(
        chalk.yellow(`Found ${errorCount} error(s), but continuing (lint.failOnError is disabled).`)
      );
    } else {
      multiLineOutro(`
        No errors found.
        You can run ${chalk.blue('mint-tsdocs generate')} to update documentation.
      `, true);
    }
  }
}
