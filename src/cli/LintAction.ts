import * as path from 'path';
import { CommandLineAction } from '@rushstack/ts-command-line';
import { FileSystem } from '@rushstack/node-core-library';
import { Colorize } from '@rushstack/terminal';
import * as clack from '@clack/prompts';
import { ESLint } from 'eslint';
import { Extractor, ExtractorConfig, type ExtractorResult } from '@microsoft/api-extractor';
import { loadConfig, generateApiExtractorConfig } from '../config';
import { DocumentationError, ErrorCode } from '../errors/DocumentationError';
import { showCliHeader } from './CliHelpers';
import { IssueDisplayUtils, type IssueMessage, type IssueGroup, type IssueSeverity } from './IssueDisplayUtils';

/**
 * CLI action for linting documentation quality.
 *
 * @public
 */
export class LintAction extends CommandLineAction {
  public constructor() {
    super({
      actionName: 'lint',
      summary: 'Check documentation quality and find issues',
      documentation:
        'Analyzes API documentation and reports:\n' +
        '  - Undocumented public APIs\n' +
        '  - Missing parameter descriptions\n' +
        '  - Missing return type descriptions\n' +
        '  - Missing examples for complex APIs\n\n' +
        'Examples:\n' +
        '  mint-tsdocs lint\n' +
        '  mint-tsdocs lint --help'
    });
  }

  protected override async onExecuteAsync(): Promise<void> {

    showCliHeader();
    clack.log.message(Colorize.bold('Documentation Linting'));

    try {
      const config = loadConfig(process.cwd());

      // Resolve paths
      const projectDir = process.cwd();
      const tsdocsDir = path.join(projectDir, 'docs', '.tsdocs');

      // Use existing api-extractor.json from .tsdocs (generated by generate command)
      const apiExtractorConfigPath = path.join(tsdocsDir, 'api-extractor.json');

      if (!FileSystem.exists(apiExtractorConfigPath)) {
        clack.log.error('No api-extractor.json found.');
        clack.outro(
          'Run ' + Colorize.cyan('mint-tsdocs generate') + ' first to generate the API Extractor configuration'
        );
        return;
      }

      // Collections for all issues
      const issueGroups = new Map<string, IssueMessage[]>();
      const ungroupedIssues: IssueMessage[] = [];

      // Step 1: Run api-extractor to collect TSDoc/syntax warnings
      clack.log.info('Running API Extractor to analyze TSDoc...');
      await this._runApiExtractor(apiExtractorConfigPath, issueGroups, ungroupedIssues);

      // Step 2: Run ESLint with tsdoc plugin
      clack.log.info('Running ESLint with TSDoc plugin...');
      await this._runESLint(config, projectDir, issueGroups, ungroupedIssues);

      // Display all collected issues
      this._displayIssues(issueGroups, ungroupedIssues);
    } catch (error) {
      if (error instanceof DocumentationError && error.code === ErrorCode.CONFIG_NOT_FOUND) {
        clack.log.error('No mint-tsdocs configuration found.');
        clack.outro('Run ' + Colorize.cyan('mint-tsdocs init') + ' to create a configuration file');
      } else {
        throw error;
      }
    }
  }

  /**
   * Run API Extractor to collect TSDoc syntax warnings
   */
  private async _runApiExtractor(
    configPath: string,
    issueGroups: Map<string, IssueMessage[]>,
    ungroupedIssues: IssueMessage[]
  ): Promise<void> {
    try {
      const extractorConfig: ExtractorConfig = ExtractorConfig.loadFileAndPrepare(configPath);

      // Intercept console to suppress api-extractor's output
      const originalConsoleLog = console.log;
      const originalConsoleError = console.error;
      const originalConsoleWarn = console.warn;

      console.log = () => { };
      console.error = () => { };
      console.warn = () => { };

      try {
        // Run api-extractor with message callback
        const extractorResult: ExtractorResult = Extractor.invoke(extractorConfig, {
          localBuild: true,
          showVerboseMessages: false,
          messageCallback: (message: any) => {
            // Skip suppressed messages
            if (message.logLevel === 'none') {
              return;
            }

            // Create issue message
            const issue: IssueMessage = {
              text: message.text,
              severity: IssueDisplayUtils.logLevelToSeverity(message.logLevel),
              line: message.sourceFileLine,
              column: message.sourceFileColumn
            };

            // Group by file or collect without location
            if (message.sourceFilePath) {
              const fileKey = message.sourceFilePath;
              if (!issueGroups.has(fileKey)) {
                issueGroups.set(fileKey, []);
              }
              issueGroups.get(fileKey)!.push(issue);
            } else {
              ungroupedIssues.push(issue);
            }
          }
        });

        if (!extractorResult.succeeded) {
          clack.log.warn(
            `API Extractor completed with ${extractorResult.errorCount} errors and ${extractorResult.warningCount} warnings`
          );
        }
      } finally {
        // Restore console
        console.log = originalConsoleLog;
        console.error = originalConsoleError;
        console.warn = originalConsoleWarn;
      }
    } catch (error) {
      clack.log.warn('API Extractor analysis failed: ' + (error instanceof Error ? error.message : String(error)));
    }
  }

  /**
   * Run ESLint with tsdoc plugin on source files
   */
  private async _runESLint(
    config: any,
    projectDir: string,
    issueGroups: Map<string, IssueMessage[]>,
    ungroupedIssues: IssueMessage[]
  ): Promise<void> {
    try {
      // Determine source directory
      const srcDir = path.join(projectDir, 'src');
      if (!FileSystem.exists(srcDir)) {
        // Skip ESLint if no src directory
        return;
      }

      // Import plugins (ESLint 9 format)
      const tsdocPlugin = await import('eslint-plugin-tsdoc');
      // @ts-expect-error - Dynamic import type resolution issue with CommonJS
      const typescriptParser = await import('@typescript-eslint/parser');

      // Create ESLint instance with tsdoc plugin
      const eslint = new ESLint({
        overrideConfigFile: true,
        overrideConfig: [{
          plugins: {
            tsdoc: tsdocPlugin.default
          },
          rules: {
            'tsdoc/syntax': 'warn'
          },
          languageOptions: {
            parser: typescriptParser.default
          }
        }],
        cwd: projectDir
      });

      // Lint all TypeScript files in src
      const results = await eslint.lintFiles([path.join(srcDir, '**/*.ts')]);

      // Convert ESLint results to grouped format
      for (const result of results) {
        if (result.messages.length === 0) continue;

        const filePath = result.filePath;

        for (const message of result.messages) {
          // Skip if no tsdoc-related message
          if (!message.ruleId || !message.ruleId.startsWith('tsdoc/')) {
            continue;
          }

          const severity: IssueSeverity =
            message.severity === 2
              ? 'error'
              : message.severity === 1
              ? 'warning'
              : 'info';

          const issue: IssueMessage = {
            text: `${message.message} (${message.ruleId})`,
            severity,
            line: message.line,
            column: message.column
          };

          if (!issueGroups.has(filePath)) {
            issueGroups.set(filePath, []);
          }
          issueGroups.get(filePath)!.push(issue);
        }
      }
    } catch (error) {
      // Silently skip ESLint if it fails (e.g., no TypeScript parser)
      clack.log.warn('ESLint analysis skipped (install @typescript-eslint/parser for TSDoc linting)');
    }
  }

  /**
   * Display lint issues using grouped format
   */
  private _displayIssues(
    issueGroups: Map<string, IssueMessage[]>,
    ungroupedIssues: IssueMessage[]
  ): void {
    // Count total issues and by severity
    let totalIssues = ungroupedIssues.length;
    let errorCount = 0;
    let warningCount = 0;
    let infoCount = 0;

    for (const issues of issueGroups.values()) {
      totalIssues += issues.length;
      for (const issue of issues) {
        if (issue.severity === 'error') errorCount++;
        else if (issue.severity === 'warning') warningCount++;
        else if (issue.severity === 'info') infoCount++;
      }
    }

    for (const issue of ungroupedIssues) {
      if (issue.severity === 'error') errorCount++;
      else if (issue.severity === 'warning') warningCount++;
      else if (issue.severity === 'info') infoCount++;
    }

    if (totalIssues === 0) {
      console.log('\n' + Colorize.green('âœ“ No documentation issues found!'));
      clack.outro('Your documentation looks great!');
      return;
    }

    // Convert Map to IssueGroup array
    const groups: IssueGroup[] = Array.from(issueGroups.entries()).map(([filePath, issues]) => ({
      filePath,
      issues
    }));

    // Display grouped issues using IssueDisplayUtils
    IssueDisplayUtils.displayGroupedIssues(groups, ungroupedIssues);

    // Build and display summary
    const summaryLines: string[] = [Colorize.bold('\nSummary')];
    if (errorCount > 0) {
      summaryLines.push('  Errors:          ' + Colorize.red(errorCount.toString()));
    }
    if (warningCount > 0) {
      summaryLines.push('  Warnings:        ' + Colorize.yellow(warningCount.toString()));
    }
    if (infoCount > 0) {
      summaryLines.push('  Info:            ' + Colorize.cyan(infoCount.toString()));
    }

    clack.log.message(summaryLines.join('\n'));

    // Exit with error code if there are errors
    if (errorCount > 0) {
      clack.outro(Colorize.red(`Found ${errorCount} error(s). Fix these issues first.`));
      process.exitCode = 1;
    } else {
      clack.outro('Linting complete. Run `mint-tsdocs generate` to update documentation.');
    }
  }
}
