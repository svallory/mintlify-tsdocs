/**
 * Generates TypeInfo.jsx file containing TypeTreeProperty data for all API items.
 * This allows documentation authors to reference type information with IDE autocomplete.
 *
 * @packageDocumentation
 */

import {
  ApiModel,
  ApiItem,
  ApiItemKind,
  ApiInterface,
  ApiClass,
  ApiPropertyItem,
  ApiDocumentedItem,
  ApiOptionalMixin,
  ApiReadonlyMixin,
  type ApiPackage
} from '@microsoft/api-extractor-model';
import { PackageName } from '@rushstack/node-core-library';
import { Utilities } from './Utilities';
import { createDebugger, type Debugger } from './debug';
import { ObjectTypeAnalyzer, type TypeAnalysis, type PropertyAnalysis } from './ObjectTypeAnalyzer';

const debug: Debugger = createDebugger('type-info-generator');

/**
 * Type information in TypeTree-compatible format
 */
interface TypeInfo {
  name: string;
  type: string;
  description?: string;
  required?: boolean;
  deprecated?: boolean;
  defaultValue?: string;
  properties?: TypeInfo[];
}

/**
 * Generates TypeInfo.jsx file with type information for documentation
 *
 * @see /architecture/typeinfo-generation - TypeInfo generation architecture
 * @see /components/type-info - TypeInfo component usage
 */
export class TypeInfoGenerator {
  private readonly _apiModel: ApiModel;
  private readonly _typeAnalyzer: ObjectTypeAnalyzer;

  constructor(apiModel: ApiModel) {
    this._apiModel = apiModel;
    this._typeAnalyzer = new ObjectTypeAnalyzer();
  }

  /**
   * Generate TypeInfo.jsx content as a JavaScript module
   */
  public generateTypeInfoModule(): string {
    const typeInfo = this._buildTypeInfoObject();

    const header = [
      '/**',
      ' * Auto-generated type information for TypeTree components.',
      ' * DO NOT EDIT THIS FILE MANUALLY - it will be overwritten on next generation.',
      ' * ',
      ` * Generated: ${new Date().toISOString()}`,
      ' * Generated by: mint-tsdocs',
      ' * ',
      ' * @version 1.0.0',
      ' */',
      ''
    ].join('\n');

    const content = [
      header,
      '/**',
      ' * Type information organized by package and API item.',
      ' * Use this to get TypeTreeProperty-compatible data for any documented type.',
      ' * ',
      ' * @example',
      ' * ```jsx',
      ' * import { TypeInfo } from "/snippets/tsdocs/TypeInfo.jsx"',
      ' * ',
      ' * <TypeTree {...TypeInfo.MyPackage.MyInterface} />',
      ' * ',
      ' * // Or access nested properties:',
      ' * const apiModelProp = TypeInfo.MintTsdocs.IMarkdownDocumenterOptions.properties.find(',
      ' *   p => p.name === "apiModel"',
      ' * );',
      ' * ```',
      ' */',
      `export const TypeInfo = ${JSON.stringify(typeInfo, null, 2)};`,
      ''
    ].join('\n');

    return content;
  }

  /**
   * Generate TypeInfo.d.ts for VSCode autocomplete
   */
  public generateTypeInfoDeclaration(): string {
    const typeInfo = this._buildTypeInfoObject();

    const header = [
      '/**',
      ' * Auto-generated type declarations for TypeInfo.',
      ' * DO NOT EDIT THIS FILE MANUALLY - it will be overwritten on next generation.',
      ' * ',
      ` * Generated: ${new Date().toISOString()}`,
      ' * Generated by: mint-tsdocs',
      ' * ',
      ' * This file provides VSCode autocomplete for TypeInfo imports.',
      ' * @version 1.0.0',
      ' */',
      ''
    ].join('\n');

    // Generate TypeScript interface based on the structure
    const typeDeclaration = this._generateTypeDeclaration(typeInfo);

    const content = [
      header,
      '/**',
      ' * TypeTree property structure',
      ' */',
      'export interface TypeTreeProperty {',
      '  name: string;',
      '  type: string;',
      '  description?: string;',
      '  required?: boolean;',
      '  deprecated?: boolean;',
      '  defaultValue?: string;',
      '  properties?: TypeTreeProperty[];',
      '}',
      '',
      '/**',
      ' * Type information organized by package and API item.',
      ' * Provides full autocomplete for all documented types.',
      ' */',
      `export const TypeInfo: ${typeDeclaration};`,
      ''
    ].join('\n');

    return content;
  }

  /**
   * Generate TypeScript type declaration from the TypeInfo structure
   */
  private _generateTypeDeclaration(obj: any, indent: number = 0): string {
    const spaces = '  '.repeat(indent);
    const nextSpaces = '  '.repeat(indent + 1);

    if (Array.isArray(obj)) {
      // For arrays, generate a tuple type with all elements
      if (obj.length === 0) {
        return '[]';
      }
      // Generate detailed tuple type for property arrays
      const tupleElements = obj.map(item => this._generateTypeDeclaration(item, indent + 1));
      return `[\n${nextSpaces}${tupleElements.join(`,\n${nextSpaces}`)}\n${spaces}]`;
    }

    if (typeof obj !== 'object' || obj === null) {
      return typeof obj;
    }

    // Check if this is a TypeInfo property object (has name, type)
    if (obj.name && obj.type) {
      const lines: string[] = ['{'];
      lines.push(`${nextSpaces}name: ${JSON.stringify(obj.name)};`);
      lines.push(`${nextSpaces}type: ${JSON.stringify(obj.type)};`);

      if (obj.description !== undefined) {
        lines.push(`${nextSpaces}description?: ${JSON.stringify(obj.description)};`);
      }
      if (obj.required !== undefined) {
        lines.push(`${nextSpaces}required?: ${obj.required};`);
      }
      if (obj.deprecated !== undefined) {
        lines.push(`${nextSpaces}deprecated?: ${obj.deprecated};`);
      }
      if (obj.defaultValue !== undefined) {
        lines.push(`${nextSpaces}defaultValue?: ${JSON.stringify(obj.defaultValue)};`);
      }

      // Recursively generate type for nested properties
      if (obj.properties && Array.isArray(obj.properties)) {
        const propertiesType = this._generateTypeDeclaration(obj.properties, indent + 1);
        lines.push(`${nextSpaces}properties?: ${propertiesType};`);
      }

      lines.push(`${spaces}}`);
      return lines.join('\n');
    }

    // Otherwise, it's a nested structure (package/items) - generate object type
    const entries = Object.entries(obj);
    if (entries.length === 0) {
      return '{}';
    }

    const lines: string[] = ['{'];

    for (const [key, value] of entries) {
      const propertyType = this._generateTypeDeclaration(value, indent + 1);
      lines.push(`${nextSpaces}"${key}": ${propertyType};`);
    }

    lines.push(`${spaces}}`);
    return lines.join('\n');
  }

  /**
   * Build the complete TypeInfo object structure
   */
  private _buildTypeInfoObject(): Record<string, any> {
    const result: Record<string, any> = {};

    for (const packageItem of this._apiModel.packages) {
      const packageName = this._getPackageKey(packageItem);
      result[packageName] = this._processPackage(packageItem);
    }

    return result;
  }

  /**
   * Get a safe key name for a package
   */
  private _getPackageKey(packageItem: ApiPackage): string {
    const unscopedName = PackageName.getUnscopedName(packageItem.displayName);
    // Convert package name to PascalCase for better JS property access
    return this._toPascalCase(unscopedName);
  }

  /**
   * Process a package and extract type info for all members
   */
  private _processPackage(packageItem: ApiPackage): Record<string, any> {
    const result: Record<string, any> = {};

    // Get entry point members
    if (packageItem.entryPoints.length > 0) {
      const entryPoint = packageItem.entryPoints[0];

      for (const member of entryPoint.members) {
        const memberInfo = this._processApiItem(member);
        if (memberInfo) {
          const key = Utilities.normalizeDisplayName(member.displayName);
          result[key] = memberInfo;
        }
      }
    }

    return result;
  }

  /**
   * Process an API item and convert to TypeInfo format
   */
  private _processApiItem(apiItem: ApiItem): TypeInfo | null {
    switch (apiItem.kind) {
      case ApiItemKind.Interface:
        return this._processInterface(apiItem as ApiInterface);
      case ApiItemKind.Class:
        return this._processClass(apiItem as ApiClass);
      case ApiItemKind.TypeAlias:
        return this._processTypeAlias(apiItem);
      default:
        return null;
    }
  }

  /**
   * Process an interface and extract its properties
   */
  private _processInterface(apiInterface: ApiInterface): TypeInfo {
    const properties: TypeInfo[] = [];

    for (const member of apiInterface.members) {
      if (member.kind === ApiItemKind.PropertySignature) {
        const propertyInfo = this._processProperty(member as ApiPropertyItem);
        if (propertyInfo) {
          properties.push(propertyInfo);
        }
      }
    }

    return {
      name: apiInterface.displayName,
      type: 'interface',
      description: this._getDescription(apiInterface),
      properties: properties.length > 0 ? properties : undefined
    };
  }

  /**
   * Process a class and extract its properties
   */
  private _processClass(apiClass: ApiClass): TypeInfo {
    const properties: TypeInfo[] = [];

    for (const member of apiClass.members) {
      if (member.kind === ApiItemKind.Property) {
        const propertyInfo = this._processProperty(member as ApiPropertyItem);
        if (propertyInfo) {
          properties.push(propertyInfo);
        }
      }
    }

    return {
      name: apiClass.displayName,
      type: 'class',
      description: this._getDescription(apiClass),
      properties: properties.length > 0 ? properties : undefined
    };
  }

  /**
   * Process a type alias
   */
  private _processTypeAlias(apiTypeAlias: ApiItem): TypeInfo {
    // For type aliases, we can't easily extract nested structure without parsing
    // the type string, so we just document the type itself
    return {
      name: apiTypeAlias.displayName,
      type: 'type',
      description: this._getDescription(apiTypeAlias)
    };
  }

  /**
   * Process a property and extract its type information
   */
  private _processProperty(apiProperty: ApiPropertyItem): TypeInfo | null {
    const typeString = apiProperty.propertyTypeExcerpt.text;

    // Determine if required (not optional)
    const isRequired = ApiOptionalMixin.isBaseClassOf(apiProperty)
      ? !apiProperty.isOptional
      : true;

    // Check if readonly
    const isReadonly = ApiReadonlyMixin.isBaseClassOf(apiProperty)
      ? apiProperty.isReadonly
      : false;

    // Check if deprecated
    const isDeprecated = apiProperty instanceof ApiDocumentedItem
      ? apiProperty.tsdocComment?.deprecatedBlock !== undefined
      : false;

    // Get default value from JSDoc
    const defaultValue = this._extractDefaultValue(apiProperty);

    // Try to extract nested properties for object types
    const nestedProperties = this._extractNestedProperties(typeString);

    // Basic property info
    const propertyInfo: TypeInfo = {
      name: apiProperty.displayName,
      // Use "object" as the type if we have nested properties, otherwise simplify the type string
      type: (nestedProperties && nestedProperties.length > 0) ? 'object' : this._simplifyType(typeString),
      description: this._getDescription(apiProperty),
      required: isRequired,
      deprecated: isDeprecated || undefined,
      defaultValue: defaultValue || undefined
    };

    // Add nested properties if available
    if (nestedProperties && nestedProperties.length > 0) {
      propertyInfo.properties = nestedProperties;
    }

    return propertyInfo;
  }

  /**
   * Extract nested properties from an object type string
   */
  private _extractNestedProperties(typeString: string): TypeInfo[] | null {
    // First, try to resolve the type as a reference to another API item
    const trimmedType = typeString.trim();

    // Check if it's a simple type reference (not an inline object literal)
    if (!trimmedType.includes('{')) {
      // Try to find the referenced interface/type in the API model
      const referencedItem = this._findApiItemByName(trimmedType);
      if (referencedItem) {
        // Process the referenced item to get its properties with full documentation
        if (referencedItem.kind === ApiItemKind.Interface) {
          const interfaceItem = referencedItem as ApiInterface;
          const properties: TypeInfo[] = [];
          for (const member of interfaceItem.members) {
            if (member.kind === ApiItemKind.PropertySignature) {
              const propInfo = this._processProperty(member as ApiPropertyItem);
              if (propInfo) {
                properties.push(propInfo);
              }
            }
          }
          return properties.length > 0 ? properties : null;
        }
      }
    }

    // Fall back to parsing inline object types
    if (trimmedType.includes('{') && trimmedType.includes('}')) {
      // Use ObjectTypeAnalyzer to parse the type
      const analysis = this._typeAnalyzer.analyzeType(typeString);

      // Convert the analysis to TypeInfo format
      if (analysis.type === 'object-literal' && analysis.properties) {
        return this._convertPropertiesToTypeInfo(analysis.properties);
      }
    }

    return null;
  }

  /**
   * Find an API item by name across all packages
   */
  private _findApiItemByName(name: string): ApiItem | undefined {
    for (const packageItem of this._apiModel.packages) {
      if (packageItem.entryPoints.length > 0) {
        const entryPoint = packageItem.entryPoints[0];
        for (const member of entryPoint.members) {
          if (member.displayName === name) {
            return member;
          }
        }
      }
    }
    return undefined;
  }

  /**
   * Convert PropertyAnalysis array to TypeInfo array (recursive)
   */
  private _convertPropertiesToTypeInfo(properties: PropertyAnalysis[]): TypeInfo[] {
    return properties.map(prop => {
      const typeInfo: TypeInfo = {
        name: prop.name,
        type: this._convertTypeAnalysisToString(prop.type),
        required: !prop.optional
      };

      // Recursively handle nested properties
      if (prop.type.type === 'object-literal' && prop.type.properties) {
        typeInfo.properties = this._convertPropertiesToTypeInfo(prop.type.properties);
      }

      return typeInfo;
    });
  }

  /**
   * Convert TypeAnalysis to a readable type string
   */
  private _convertTypeAnalysisToString(analysis: TypeAnalysis): string {
    switch (analysis.type) {
      case 'primitive':
        return analysis.name || 'unknown';

      case 'array':
        if (analysis.elementType) {
          return `${this._convertTypeAnalysisToString(analysis.elementType)}[]`;
        }
        return 'unknown[]';

      case 'union':
        if (analysis.unionTypes) {
          return analysis.unionTypes
            .map(t => this._convertTypeAnalysisToString(t))
            .join(' | ');
        }
        return 'unknown';

      case 'intersection':
        if (analysis.intersectionTypes) {
          return analysis.intersectionTypes
            .map(t => this._convertTypeAnalysisToString(t))
            .join(' & ');
        }
        return 'unknown';

      case 'generic':
        if (analysis.baseType && analysis.typeParameters) {
          return `${analysis.baseType}<${analysis.typeParameters.join(', ')}>`;
        }
        return analysis.baseType || 'unknown';

      case 'object-literal':
        // For object literals, we'll use 'object' as the type
        // and the nested properties will be in the 'properties' field
        return 'object';

      case 'unknown':
      default:
        return analysis.name || 'unknown';
    }
  }

  /**
   * Simplify a TypeScript type string for display
   */
  private _simplifyType(typeString: string): string {
    // Remove extra whitespace
    let simplified = typeString.trim().replace(/\s+/g, ' ');

    // For very long types, we might want to truncate or simplify
    // For now, keep it as-is

    return simplified;
  }

  /**
   * Get description from TSDoc comment
   */
  private _getDescription(apiItem: ApiItem): string | undefined {
    if (!(apiItem instanceof ApiDocumentedItem)) {
      return undefined;
    }

    const tsdocComment = apiItem.tsdocComment;
    if (!tsdocComment?.summarySection) {
      return undefined;
    }

    // Extract plain text from summary section by recursively getting text content
    const summary = this._extractTextFromSection(tsdocComment.summarySection);

    return summary || undefined;
  }

  /**
   * Recursively extract plain text from TSDoc section
   */
  private _extractTextFromSection(section: any): string {
    let text = '';

    if (!section || !section.nodes) {
      return text;
    }

    for (const node of section.nodes) {
      if (node.kind === 'Paragraph') {
        // Recurse into paragraph nodes
        for (const child of node.getChildNodes()) {
          text += this._extractTextFromNode(child);
        }
      } else {
        text += this._extractTextFromNode(node);
      }
    }

    return text.trim();
  }

  /**
   * Extract text from a single TSDoc node
   */
  private _extractTextFromNode(node: any): string {
    if (!node) {
      return '';
    }

    // Handle PlainText nodes
    if (node.kind === 'PlainText') {
      return node.text || '';
    }

    // Handle CodeSpan nodes
    if (node.kind === 'CodeSpan') {
      return `\`${node.code || ''}\``;
    }

    // Handle LinkTag nodes
    if (node.kind === 'LinkTag') {
      return node.linkText || '';
    }

    // For other nodes with child nodes, recurse
    if (node.getChildNodes && typeof node.getChildNodes === 'function') {
      let text = '';
      for (const child of node.getChildNodes()) {
        text += this._extractTextFromNode(child);
      }
      return text;
    }

    // Fallback to empty string
    return '';
  }

  /**
   * Extract default value from @defaultValue JSDoc tag
   */
  private _extractDefaultValue(apiItem: ApiItem): string | undefined {
    if (!(apiItem instanceof ApiDocumentedItem)) {
      return undefined;
    }

    const tsdocComment = apiItem.tsdocComment;
    if (!tsdocComment?.customBlocks) {
      return undefined;
    }

    for (const block of tsdocComment.customBlocks) {
      if (block.blockTag.tagName === '@defaultValue') {
        return block.content.nodes
          .map(node => node.toString())
          .join('')
          .trim();
      }
    }

    return undefined;
  }

  /**
   * Convert kebab-case or snake_case to PascalCase
   */
  private _toPascalCase(str: string): string {
    return str
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}
