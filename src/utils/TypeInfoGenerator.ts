/**
 * Generates TypeInfo.jsx file containing TypeTreeProperty data for all API items.
 * This allows documentation authors to reference type information with IDE autocomplete.
 *
 * @packageDocumentation
 */

import {
  ApiModel,
  ApiItem,
  ApiItemKind,
  ApiInterface,
  ApiClass,
  ApiPropertyItem,
  ApiDocumentedItem,
  ApiOptionalMixin,
  ApiReadonlyMixin,
  type ApiPackage
} from '@microsoft/api-extractor-model';
import { PackageName } from '@rushstack/node-core-library';
import { Utilities } from './Utilities';
import { createDebugger, type Debugger } from './debug';

const debug: Debugger = createDebugger('type-info-generator');

/**
 * Type information in TypeTree-compatible format
 */
interface TypeInfo {
  name: string;
  type: string;
  description?: string;
  required?: boolean;
  deprecated?: boolean;
  defaultValue?: string;
  properties?: TypeInfo[];
}

/**
 * Generates TypeInfo.jsx file with type information for documentation
 */
export class TypeInfoGenerator {
  private readonly _apiModel: ApiModel;

  constructor(apiModel: ApiModel) {
    this._apiModel = apiModel;
  }

  /**
   * Generate TypeInfo.jsx content as a JavaScript module
   */
  public generateTypeInfoModule(): string {
    const typeInfo = this._buildTypeInfoObject();

    const header = [
      '/**',
      ' * Auto-generated type information for TypeTree components.',
      ' * DO NOT EDIT THIS FILE MANUALLY - it will be overwritten on next generation.',
      ' * ',
      ` * Generated: ${new Date().toISOString()}`,
      ' * Generated by: mint-tsdocs',
      ' * ',
      ' * @version 1.0.0',
      ' */',
      ''
    ].join('\n');

    const content = [
      header,
      '/**',
      ' * Type information organized by package and API item.',
      ' * Use this to get TypeTreeProperty-compatible data for any documented type.',
      ' * ',
      ' * @example',
      ' * ```jsx',
      ' * import { TypeInfo } from "/snippets/tsdocs/TypeInfo.jsx"',
      ' * ',
      ' * <TypeTree {...TypeInfo.MyPackage.MyInterface} />',
      ' * ',
      ' * // Or access nested properties:',
      ' * const apiModelProp = TypeInfo.MintTsdocs.IMarkdownDocumenterOptions.properties.find(',
      ' *   p => p.name === "apiModel"',
      ' * );',
      ' * ```',
      ' */',
      `export const TypeInfo = ${JSON.stringify(typeInfo, null, 2)};`,
      ''
    ].join('\n');

    return content;
  }

  /**
   * Generate TypeInfo.d.ts for VSCode autocomplete
   */
  public generateTypeInfoDeclaration(): string {
    const typeInfo = this._buildTypeInfoObject();

    const header = [
      '/**',
      ' * Auto-generated type declarations for TypeInfo.',
      ' * DO NOT EDIT THIS FILE MANUALLY - it will be overwritten on next generation.',
      ' * ',
      ` * Generated: ${new Date().toISOString()}`,
      ' * Generated by: mint-tsdocs',
      ' * ',
      ' * This file provides VSCode autocomplete for TypeInfo imports.',
      ' * @version 1.0.0',
      ' */',
      ''
    ].join('\n');

    // Generate TypeScript interface based on the structure
    const typeDeclaration = this._generateTypeDeclaration(typeInfo);

    const content = [
      header,
      '/**',
      ' * TypeTree property structure',
      ' */',
      'export interface TypeTreeProperty {',
      '  name: string;',
      '  type: string;',
      '  description?: string;',
      '  required?: boolean;',
      '  deprecated?: boolean;',
      '  defaultValue?: string;',
      '  properties?: TypeTreeProperty[];',
      '}',
      '',
      '/**',
      ' * Type information organized by package and API item.',
      ' * Provides full autocomplete for all documented types.',
      ' */',
      `export const TypeInfo: ${typeDeclaration};`,
      ''
    ].join('\n');

    return content;
  }

  /**
   * Generate TypeScript type declaration from the TypeInfo structure
   */
  private _generateTypeDeclaration(obj: any, indent: number = 0): string {
    const spaces = '  '.repeat(indent);
    const nextSpaces = '  '.repeat(indent + 1);

    if (Array.isArray(obj)) {
      return 'TypeTreeProperty[]';
    }

    if (typeof obj !== 'object' || obj === null) {
      return typeof obj;
    }

    // Check if this is a TypeInfo property object
    if (obj.name && obj.type && !obj.properties) {
      return 'TypeTreeProperty';
    }

    if (obj.name && obj.type && obj.properties) {
      return 'TypeTreeProperty';
    }

    // Otherwise, it's a nested structure - generate object type
    const entries = Object.entries(obj);
    if (entries.length === 0) {
      return '{}';
    }

    const lines: string[] = ['{'];

    for (const [key, value] of entries) {
      const propertyType = this._generateTypeDeclaration(value, indent + 1);
      lines.push(`${nextSpaces}"${key}": ${propertyType};`);
    }

    lines.push(`${spaces}}`);
    return lines.join('\n');
  }

  /**
   * Build the complete TypeInfo object structure
   */
  private _buildTypeInfoObject(): Record<string, any> {
    const result: Record<string, any> = {};

    for (const packageItem of this._apiModel.packages) {
      const packageName = this._getPackageKey(packageItem);
      result[packageName] = this._processPackage(packageItem);
    }

    return result;
  }

  /**
   * Get a safe key name for a package
   */
  private _getPackageKey(packageItem: ApiPackage): string {
    const unscopedName = PackageName.getUnscopedName(packageItem.displayName);
    // Convert package name to PascalCase for better JS property access
    return this._toPascalCase(unscopedName);
  }

  /**
   * Process a package and extract type info for all members
   */
  private _processPackage(packageItem: ApiPackage): Record<string, any> {
    const result: Record<string, any> = {};

    // Get entry point members
    if (packageItem.entryPoints.length > 0) {
      const entryPoint = packageItem.entryPoints[0];

      for (const member of entryPoint.members) {
        const memberInfo = this._processApiItem(member);
        if (memberInfo) {
          const key = Utilities.normalizeDisplayName(member.displayName);
          result[key] = memberInfo;
        }
      }
    }

    return result;
  }

  /**
   * Process an API item and convert to TypeInfo format
   */
  private _processApiItem(apiItem: ApiItem): TypeInfo | null {
    switch (apiItem.kind) {
      case ApiItemKind.Interface:
        return this._processInterface(apiItem as ApiInterface);
      case ApiItemKind.Class:
        return this._processClass(apiItem as ApiClass);
      case ApiItemKind.TypeAlias:
        return this._processTypeAlias(apiItem);
      default:
        return null;
    }
  }

  /**
   * Process an interface and extract its properties
   */
  private _processInterface(apiInterface: ApiInterface): TypeInfo {
    const properties: TypeInfo[] = [];

    for (const member of apiInterface.members) {
      if (member.kind === ApiItemKind.PropertySignature) {
        const propertyInfo = this._processProperty(member as ApiPropertyItem);
        if (propertyInfo) {
          properties.push(propertyInfo);
        }
      }
    }

    return {
      name: apiInterface.displayName,
      type: 'interface',
      description: this._getDescription(apiInterface),
      properties: properties.length > 0 ? properties : undefined
    };
  }

  /**
   * Process a class and extract its properties
   */
  private _processClass(apiClass: ApiClass): TypeInfo {
    const properties: TypeInfo[] = [];

    for (const member of apiClass.members) {
      if (member.kind === ApiItemKind.Property) {
        const propertyInfo = this._processProperty(member as ApiPropertyItem);
        if (propertyInfo) {
          properties.push(propertyInfo);
        }
      }
    }

    return {
      name: apiClass.displayName,
      type: 'class',
      description: this._getDescription(apiClass),
      properties: properties.length > 0 ? properties : undefined
    };
  }

  /**
   * Process a type alias
   */
  private _processTypeAlias(apiTypeAlias: ApiItem): TypeInfo {
    // For type aliases, we can't easily extract nested structure without parsing
    // the type string, so we just document the type itself
    return {
      name: apiTypeAlias.displayName,
      type: 'type',
      description: this._getDescription(apiTypeAlias)
    };
  }

  /**
   * Process a property and extract its type information
   */
  private _processProperty(apiProperty: ApiPropertyItem): TypeInfo | null {
    const typeString = apiProperty.propertyTypeExcerpt.text;

    // Determine if required (not optional)
    const isRequired = ApiOptionalMixin.isBaseClassOf(apiProperty)
      ? !apiProperty.isOptional
      : true;

    // Check if readonly
    const isReadonly = ApiReadonlyMixin.isBaseClassOf(apiProperty)
      ? apiProperty.isReadonly
      : false;

    // Check if deprecated
    const isDeprecated = apiProperty instanceof ApiDocumentedItem
      ? apiProperty.tsdocComment?.deprecatedBlock !== undefined
      : false;

    // Get default value from JSDoc
    const defaultValue = this._extractDefaultValue(apiProperty);

    // Basic property info
    const propertyInfo: TypeInfo = {
      name: apiProperty.displayName,
      type: this._simplifyType(typeString),
      description: this._getDescription(apiProperty),
      required: isRequired,
      deprecated: isDeprecated || undefined,
      defaultValue: defaultValue || undefined
    };

    // Try to extract nested properties for object types
    const nestedProperties = this._extractNestedProperties(typeString);
    if (nestedProperties && nestedProperties.length > 0) {
      propertyInfo.properties = nestedProperties;
    }

    return propertyInfo;
  }

  /**
   * Extract nested properties from an object type string
   */
  private _extractNestedProperties(typeString: string): TypeInfo[] | null {
    // Simple heuristic: if it's an object literal type with braces
    if (!typeString.includes('{') || !typeString.includes('}')) {
      return null;
    }

    // This is a simplified parser - for production, you'd use ObjectTypeAnalyzer
    // For now, we'll just return null and let the type string speak for itself
    // This can be enhanced later with the full ObjectTypeAnalyzer integration

    return null;
  }

  /**
   * Simplify a TypeScript type string for display
   */
  private _simplifyType(typeString: string): string {
    // Remove extra whitespace
    let simplified = typeString.trim().replace(/\s+/g, ' ');

    // For very long types, we might want to truncate or simplify
    // For now, keep it as-is

    return simplified;
  }

  /**
   * Get description from TSDoc comment
   */
  private _getDescription(apiItem: ApiItem): string | undefined {
    if (!(apiItem instanceof ApiDocumentedItem)) {
      return undefined;
    }

    const tsdocComment = apiItem.tsdocComment;
    if (!tsdocComment?.summarySection) {
      return undefined;
    }

    // Extract plain text from summary section by recursively getting text content
    const summary = this._extractTextFromSection(tsdocComment.summarySection);

    return summary || undefined;
  }

  /**
   * Recursively extract plain text from TSDoc section
   */
  private _extractTextFromSection(section: any): string {
    let text = '';

    if (!section || !section.nodes) {
      return text;
    }

    for (const node of section.nodes) {
      if (node.kind === 'Paragraph') {
        // Recurse into paragraph nodes
        for (const child of node.getChildNodes()) {
          text += this._extractTextFromNode(child);
        }
      } else {
        text += this._extractTextFromNode(node);
      }
    }

    return text.trim();
  }

  /**
   * Extract text from a single TSDoc node
   */
  private _extractTextFromNode(node: any): string {
    if (!node) {
      return '';
    }

    // Handle PlainText nodes
    if (node.kind === 'PlainText') {
      return node.text || '';
    }

    // Handle CodeSpan nodes
    if (node.kind === 'CodeSpan') {
      return `\`${node.code || ''}\``;
    }

    // Handle LinkTag nodes
    if (node.kind === 'LinkTag') {
      return node.linkText || '';
    }

    // For other nodes with child nodes, recurse
    if (node.getChildNodes && typeof node.getChildNodes === 'function') {
      let text = '';
      for (const child of node.getChildNodes()) {
        text += this._extractTextFromNode(child);
      }
      return text;
    }

    // Fallback to empty string
    return '';
  }

  /**
   * Extract default value from @defaultValue JSDoc tag
   */
  private _extractDefaultValue(apiItem: ApiItem): string | undefined {
    if (!(apiItem instanceof ApiDocumentedItem)) {
      return undefined;
    }

    const tsdocComment = apiItem.tsdocComment;
    if (!tsdocComment?.customBlocks) {
      return undefined;
    }

    for (const block of tsdocComment.customBlocks) {
      if (block.blockTag.tagName === '@defaultValue') {
        return block.content.nodes
          .map(node => node.toString())
          .join('')
          .trim();
      }
    }

    return undefined;
  }

  /**
   * Convert kebab-case or snake_case to PascalCase
   */
  private _toPascalCase(str: string): string {
    return str
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}
